I"xM<h2 id="属性">属性</h2>

<ul>
  <li>Swift中跟实例相关的属性可以分为2大类</li>
  <li><strong>存储属性(Stored Property)</strong>
    <ul>
      <li>类似于成员变量这个概念</li>
      <li>存储在实例的内存中</li>
      <li>结构体、类可以定义存储属性 ü 枚举不可以定义存储属性</li>
    </ul>
  </li>
  <li><strong>计算属性(Computed Property)</strong>
    <ul>
      <li>本质就是方法(函数)</li>
      <li>不占用实例的内存</li>
      <li>枚举、结构体、类都可以定义计算属性</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Circle { // 存储属性
    var radius: Double
    // 计算属性
    var diameter: Double {
        set {
            radius = newValue / 2
        } get {
            radius * 2
        }
    }
}

var circle = Circle(radius: 5)
print(circle.radius) // 5.0
print(circle.diameter) // 10.0
circle.diameter = 12
print(circle.radius) // 6.0
print(circle.diameter) // 12.0
print(MemoryLayout&lt;Circle&gt;.stride) // 8
</code></pre></div></div>

<hr />

<h3 id="存储属性">存储属性</h3>

<ul>
  <li>关于存储属性，Swift有个明确的规定
    <ul>
      <li>在创建类 或 结构体的实例时，必须为所有的存储属性设置一个合适的初始值
        <ul>
          <li>可以在初始化器里为存储属性设置一个初始值</li>
          <li>可以分配一个默认的属性值作为属性定义的一部分</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="计算属性">计算属性</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">set</code>传入的新值默认叫做``newValue，也可以自定义</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Circle {
    var radius: Double
    var diameter: Double {
        set(newDiameter) {
            radius = newDiameter / 2
        }
        get {
            radius * 2
        }
    }
}
</code></pre></div></div>

<ul>
  <li>定义计算属性只能用<code class="language-plaintext highlighter-rouge">var</code>，不能用<code class="language-plaintext highlighter-rouge">let</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">let</code>代表常量:值是一成不变的</li>
      <li>计算属性的值是可能发生变化的(即使是只读计算属性)</li>
    </ul>
  </li>
  <li>只读计算属性:只有<code class="language-plaintext highlighter-rouge">get</code>，没有<code class="language-plaintext highlighter-rouge">set</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Circle {
    var radius: Double
    var diameter: Double {
        get {
            radius * 2
        }
    }
}
struct Circle {
    var radius: Double
    var diameter: Double { radius * 2 }
}
</code></pre></div></div>

<hr />

<h3 id="枚举rawvalue原理">枚举rawValue原理</h3>

<ul>
  <li>枚举原始值rawValue的本质是：只读计算属性</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum TestEnum : Int {
    case test1 = 1, test2 = 2, test3 = 3
    var rawValue: Int {
        switch self {
        case .test1:
            return 10
        case .test2:
            return 11
        case .test3:
            return 12
        }
    }
}
print(TestEnum.test3.rawValue) // 12
</code></pre></div></div>

<hr />

<h3 id="延迟存储属性lazy-stored-property">延迟存储属性(Lazy Stored Property)</h3>

<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">lazy</code>可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Car {
    init() {
        print("Car init!")
    }
    func run() {
        print("Car is running!")
    }
}

class Person {
    lazy var car = Car()
    init() {
        print("Person init!")
    }
    func goOut() {
        car.run()
    }
}

let p = Person()
print("--------")
p.goOut()

//打印结果
Person init!
--------
Car init!
Car is running!
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lazy</code>属性必须是<code class="language-plaintext highlighter-rouge">var</code>，不能是<code class="language-plaintext highlighter-rouge">let</code>
    <ul>
      <li>let必须在实例的初始化方法完成之前就拥有值</li>
    </ul>
  </li>
  <li>如果多条线程同时第一次访问<code class="language-plaintext highlighter-rouge">lazy</code>属性</li>
  <li>无法保证属性只被初始化1次</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class PhotoView {
    lazy var image: Image = {
        let url = "https://www.baidu.com/xx.png"
        let data = Data(url: url)
        return Image(data: data)
    }()
}
</code></pre></div></div>

<hr />

<h3 id="延迟存储属性注意点">延迟存储属性注意点</h3>

<ul>
  <li>当结构体包含一个延迟存储属性时，只有<code class="language-plaintext highlighter-rouge">var</code>才能访问延迟存储属性
    <ul>
      <li>因为延迟属性初始化时需要改变结构体的内存</li>
    </ul>
  </li>
</ul>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000029.jpg" alt="" /></p>

<hr />

<h3 id="属性观察器property-observer">属性观察器(Property Observer)</h3>

<ul>
  <li>可以为非<code class="language-plaintext highlighter-rouge">lazy</code>的<code class="language-plaintext highlighter-rouge">var存储属性</code>设置属性观察器</li>
  <li><code class="language-plaintext highlighter-rouge">willSet</code>会传递新值，默认叫newValue</li>
  <li><code class="language-plaintext highlighter-rouge">didSet</code>会传递旧值，默认叫oldValue</li>
  <li>在初始化器中设置属性值不会触发<code class="language-plaintext highlighter-rouge">willSet</code>和<code class="language-plaintext highlighter-rouge">didSet</code>
    <ul>
      <li>在属性定义时设置初始值也不会触发<code class="language-plaintext highlighter-rouge">willSet</code>和<code class="language-plaintext highlighter-rouge">didSet</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Circle {
    var radius: Double {
        willSet {
            print("willSet", newValue)
        }
        didSet {
            print("didSet", oldValue, radius)
        }
    }
    init() {
        self.radius = 1.0
        print("Circle init!")
    }
}

// Circle init!
var circle = Circle()
// willSet 10.5
// didSet 1.0 10.5
circle.radius = 10.5
// 10.5
print(circle.radius)
</code></pre></div></div>

<hr />

<h3 id="全局变量局部变量">全局变量、局部变量</h3>

<ul>
  <li>属性观察器、计算属性的功能，同样可以应用在全局变量、局部变量身上</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var num: Int {
    get {
        return 10
    }
    set {
        print("setNum", newValue)
    }
}
num = 11 // setNum 11
print(num) // 10

func test() {
    var age = 10 {
        willSet {
            print("willSet", newValue)
        }
        didSet {
            print("didSet", oldValue, age)
        }
    }
    age = 11
    // willSet 11
    // didSet 10 11
}
test()
</code></pre></div></div>

<hr />

<h3 id="inout的再次研究">inout的再次研究</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Shape {
    var width: Int
    var side: Int {
        willSet {
            print("willSetSide", newValue)
        }
        didSet {
            print("didSetSide", oldValue, side)
        }
    }
    var girth: Int {
        set {
            width = newValue / side
            print("setGirth", newValue)
        }
        get {
            print("getGirth")
            return width * side
        }
    }
    func show() {
        print("width=\(width), side=\(side), girth=\(girth)")
    }
}

func test(_ num: inout Int) {
    num = 20
}

var s = Shape(width: 10, side: 4)
test(&amp;s.width)
s.show()
print("----------")
test(&amp;s.side)
s.show()
print("----------")
test(&amp;s.girth)
s.show()
 

//打印结果
getGirth
width=20, side=4, girth=80
----------
willSetSide 20
didSetSide 4 20
getGirth
width=20, side=20, girth=400
----------
getGirth
setGirth 20
getGirth
width=1, side=20, girth=20
</code></pre></div></div>

<hr />

<h3 id="inout的本质总结">inout的本质总结</h3>

<ul>
  <li>如果实参有物理内存地址，且没有设置属性观察器
    <ul>
      <li>直接将实参的内存地址传入函数(实参进行引用传递)</li>
    </ul>
  </li>
  <li>如果实参是计算属性 或者 设置了属性观察器
    <ul>
      <li>采取了Copy In Copy Out的做法
        <ul>
          <li>调用该函数时，先复制实参的值，产生副本【get】</li>
          <li>将副本的内存地址传入函数(副本进行引用传递)，在函数内部可以修改副本的值</li>
          <li>函数返回后，再将副本的值覆盖实参的值【set】</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>总结:inout的本质就是引用传递(地址传递)</li>
</ul>

<hr />

<h3 id="类型属性type-property">类型属性(Type Property)</h3>

<ul>
  <li>严格来说，属性可以分为
    <ul>
      <li>实例属性(Instance Property):只能通过实例去访问
        <ul>
          <li>存储实例属性(Stored Instance Property):存储在实例的内存中，每个实例都有1份</li>
          <li>计算实例属性(Computed Instance Property)</li>
        </ul>
      </li>
      <li>类型属性(Type Property):只能通过类型去访问
        <ul>
          <li>存储类型属性(Stored Type Property):整个程序运行过程中，就只有1份内存(类似于全局变量)</li>
          <li>计算类型属性(Computed Type Property)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>可以通过static定义类型属性
    <ul>
      <li>如果是类，也可以用关键字class</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Car {
    static var count: Int = 0
    init() {
        Car.count += 1 }
}
let c1 = Car()
let c2 = Car()
let c3 = Car() print(Car.count) // 3
</code></pre></div></div>

<hr />

<h3 id="类型属性细节">类型属性细节</h3>

<ul>
  <li>不同于<strong>存储实例属性</strong>，你必须给<strong>存储类型属性</strong>设定初始值
    <ul>
      <li>因为类型没有像实例那样的<code class="language-plaintext highlighter-rouge">init</code>初始化器来初始化存储属性</li>
    </ul>
  </li>
  <li><strong>存储类型属性</strong>默认就是<code class="language-plaintext highlighter-rouge">lazy</code>，会在第一次使用的时候才初始化</li>
  <li>就算被多个线程同时访问，保证只会初始化一次</li>
  <li><strong>存储类型属性</strong>可以是<code class="language-plaintext highlighter-rouge">let</code></li>
  <li>枚举类型也可以定义类型属性(<strong>存储类型属性、计算类型属性</strong>)</li>
</ul>

<hr />

<h3 id="单例模式">单例模式</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class FileManager {
    public static let shared = FileManager()
    private init() { }
}

public class FileManager {
    public static let shared = {
        // ....
        // ....
        return FileManager()
    }()
    private init() { }
}
</code></pre></div></div>

<hr />

<h2 id="方法method">方法(Method)</h2>

<ul>
  <li>枚举、结构体、类都可以定义实例方法、类型方法
    <ul>
      <li>实例方法(Instance Method)：通过实例对象调用</li>
      <li>类型方法(Type Method)：通过类型调用，用<code class="language-plaintext highlighter-rouge">static</code>或者<code class="language-plaintext highlighter-rouge">class</code>关键字定义</li>
    </ul>
  </li>
  <li>self
    <ul>
      <li>在实例方法中代表实例对象</li>
      <li>在类型方法中代表类型</li>
    </ul>
  </li>
  <li>在类型方法<code class="language-plaintext highlighter-rouge">static</code> <code class="language-plaintext highlighter-rouge">func</code> <code class="language-plaintext highlighter-rouge">getCount</code>中
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cout</code>等价于<code class="language-plaintext highlighter-rouge">self.cout</code>、<code class="language-plaintext highlighter-rouge">Car.self.cout</code>、<code class="language-plaintext highlighter-rouge">Car.cout</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Car {
    static var cout = 0
    init() {
        Car.cout += 1 }
    static func getCount() -&gt; Int { cout }
}

let c0 = Car()
let c1 = Car()
let c2 = Car()
print(Car.getCount()) // 3
</code></pre></div></div>

<hr />

<h3 id="mutating">mutating</h3>

<ul>
  <li>结构体和枚举是值类型，默认情况下，值类型的属性不能被自身的实例方法修改
    <ul>
      <li>在<code class="language-plaintext highlighter-rouge">func</code>关键字前加<code class="language-plaintext highlighter-rouge">mutating</code>可以允许这种修改行为</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(deltaX: Double, deltaY: Double) {
        x += deltaX
        y += deltaY
        // self = Point(x: x + deltaX, y: y + deltaY)
    }
}

enum StateSwitch {
    case low, middle, high
    mutating func next() {
        switch self {
        case .low:
            self = .middle
        case .middle:
            self = .high
        case .high:
            self = .low
        }
    }
}
</code></pre></div></div>

<hr />

<h3 id="discardableresult">@discardableResult</h3>

<ul>
  <li>在<code class="language-plaintext highlighter-rouge">func</code>前面加个<code class="language-plaintext highlighter-rouge">@discardableResult</code>，可以消除：函数调用后返回值未被使用的警告⚠️</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Point {
    var x = 0.0, y = 0.0
    @discardableResult mutating
    func moveX(deltaX: Double) -&gt; Double {
        x += deltaX
        return x
    }
}
var p = Point()
p.moveX(deltaX: 10)

@discardableResult
func get() -&gt; Int {
    return 10
}
get()
</code></pre></div></div>

<hr />

<h2 id="下标subscript">下标(subscript)</h2>

<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">subscript</code>可以给任意类型(枚举、结构体、类)增加下标功能，有些地方也翻译为：下标脚本
    <ul>
      <li><code class="language-plaintext highlighter-rouge">subscript</code>的语法类似于实例方法、计算属性，本质就是方法(函数)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">subscript</code>中定义的返回值类型决定了
    <ul>
      <li><code class="language-plaintext highlighter-rouge">get</code>方法的返回值类型</li>
      <li><code class="language-plaintext highlighter-rouge">set</code>方法中newValue的类型</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">subscript</code>可以接受多个参数，并且类型任意</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point {
    var x = 0.0, y = 0.0
    subscript(index: Int) -&gt; Double {
        set {
            if index == 0 {
                x = newValue
            } else if index == 1 {
                y = newValue
            }
        }
        get {
            if index == 0 {
                return x
            } else if index == 1 {
                return y
            }
            return 0
        }
    }
}

var p = Point()
p[0] = 11.1
p[1] = 22.2
print(p.x) // 11.1
print(p.y) // 22.2
print(p[0]) // 11.1
print(p[1]) // 22.2
</code></pre></div></div>

<hr />

<h3 id="下标的细节">下标的细节</h3>

<ul>
  <li>subscript可以没有set方法，但必须要有get方法</li>
  <li>如果只有get方法，可以省略get</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point {
    var x = 0.0, y = 0.0
    subscript(index: Int) -&gt; Double {
        get {
            if index == 0 {
                return x
            } else if index == 1 {
                return y
            }
            return 0
        }
    }
}


class Point {
    var x = 0.0, y = 0.0
    subscript(index: Int) -&gt; Double {
        if index == 0 {
            return x
        } else if index == 1 {
            return y
        }
        return 0
    }
}
</code></pre></div></div>

<ul>
  <li>可以设置参数标签</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point {
    var x = 0.0, y = 0.0
    subscript(index i: Int) -&gt; Double {
        if i == 0 {
            return x
        } else if i == 1 {
            return y
        }
        return 0
    }
}

var p = Point()
p.y = 22.2
print(p[index: 1]) // 22.2
</code></pre></div></div>

<ul>
  <li>下标可以是类型方法</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Sum {
static subscript(v1: Int, v2: Int) -&gt; Int {
        return v1 + v2
    }
}
print(Sum[10, 20]) // 30
</code></pre></div></div>

<hr />

<h3 id="结构体类作为返回值对比">结构体、类作为返回值对比</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point {
    var x = 0, y = 0
}
class PointManager {
    var point = Point()
    subscript(index: Int) -&gt; Point {
        get { point }
    }
}


struct Point {
    var x = 0, y = 0
}
class PointManager {
    var point = Point()
    subscript(index: Int) -&gt; Point {
        set { point = newValue }
        get { point } }
}

var pm = PointManager()
pm[0].x = 11
pm[0].y = 22
// Point(x: 11, y: 22)
print(pm[0])
// Point(x: 11, y: 22)
print(pm.point)
</code></pre></div></div>

<hr />

<h3 id="接收多个参数的下标">接收多个参数的下标</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Grid {
    var data = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]
    ]
    subscript(row: Int, column: Int) -&gt; Int {
        set {
            guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else {
                return
            }
            data[row][column] = newValue
        }
        get {
            guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else {
                return 0
            }
            return data[row][column] }
    }
}

var grid = Grid()
grid[0, 1] = 77
grid[1, 2] = 88
grid[2, 0] = 99
print(grid.data)
</code></pre></div></div>

:ET