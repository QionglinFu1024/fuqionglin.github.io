I"ø<h2 id="1-åè°ƒè¯•sysctl">1. åè°ƒè¯•sysctl</h2>

<p>ç³»ç»Ÿå‡½æ•° ç›‘æµ‹åº”ç”¨æ˜¯å¦è¢«è°ƒè¯•</p>

<pre><code class="language-objective-c">#import "ViewController.h"
#import &amp;lt;sys/sysctl.h&gt;

@interface ViewController ()
@end
  
static dispatch_source_t timer;

@implementation ViewController

void debugCheck(){
    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0.0 * NSEC_PER_SEC);
    dispatch_source_set_event_handler(timer, ^{
        if (isDebugger()) {
            NSLog(@"æ£€æµ‹åˆ°äº†!!");
        }else{
            NSLog(@"æ­£å¸¸!!");
        }
    });
    dispatch_resume(timer);
}

//æ£€æµ‹æ˜¯å¦è¢«è°ƒè¯•
BOOL isDebugger(){
    //æ§åˆ¶ç 
    int name[4];//é‡Œé¢æ”¾å­—èŠ‚ç .æŸ¥è¯¢ä¿¡æ¯
    name[0] = CTL_KERN;//å†…æ ¸æŸ¥çœ‹
    name[1] = KERN_PROC;//æŸ¥è¯¢è¿›ç¨‹
    name[2] = KERN_PROC_PID;//ä¼ é€’çš„å‚æ•°æ˜¯è¿›ç¨‹çš„ID(PID)
    name[3] = getpid();//PIDçš„å€¼å‘Šè¯‰
    
    struct kinfo_proc info;//æ¥å—è¿›ç¨‹æŸ¥è¯¢ç»“æœä¿¡æ¯çš„ç»“æ„ä½“
    size_t info_size = sizeof(info);//ç»“æ„ä½“çš„å¤§å°
    int error = sysctl(name, sizeof(name)/sizeof(*name), &amp;info, &amp;info_size, 0, 0);
    assert(error == 0);//0å°±æ˜¯æ²¡æœ‰é”™è¯¯,å…¶ä»–å°±æ˜¯é”™è¯¯ç 
    //p_flag æœ‰å¾ˆå¤šäºŒè¿›åˆ¶ä¿¡æ¯
    //ä¾‹å¦‚:1011 1000 1010 1010 1101 0101 1101 0101
    //&amp;
    //0000 0000 0000 1000 0000 0000 0000 0000
    // ç¬¬32ä½ == 0 ? æ²¡æœ‰  æœ‰!!
    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);
}

- (void)viewDidLoad {
    [super viewDidLoad];
    debugCheck();
}
</code></pre>

<h2 id="2ç ´è§£sysctl---fishhook">2.ç ´è§£sysctl - fishHook</h2>

<pre><code class="language-objective-c">#import "injectCode.h"
#import "fishhook.h"
#import &lt;sys/sysctl.h&gt;

@implementation injectCode
//åŸå§‹å‡½æ•°çš„åœ°å€
int (*sysctl_p)(int *, u_int, void *, size_t *, void *, size_t);
//è‡ªå®šä¹‰å‡½æ•°
int mySysctl(int *name, u_int namelen, void *info, size_t *infosize, void *newinfo, size_t newinfosize){
    if (namelen == 4
        //æ£€æŸ¥å†…æ ¸
        &amp;&amp; name[0] == CTL_KERN
        //æ£€æŸ¥å†…æ ¸çš„è¿›ç¨‹
        &amp;&amp; name[1] == KERN_PROC
         //ä¼ é€’çš„å‚æ•°æ˜¯PID
        &amp;&amp; name[2] == KERN_PROC_PID
        &amp;&amp; info
        &amp;&amp; (int)*infosize == sizeof(struct kinfo_proc))
    {
        int err = sysctl_p(name, namelen, info, infosize, newinfo, newinfosize);
        //æ‹¿å‡ºinfoåšåˆ¤æ–­
        struct kinfo_proc * myInfo = (struct kinfo_proc *)info;
        if((myInfo-&gt;kp_proc.p_flag &amp; P_TRACED) != 0){
            //ä½¿ç”¨å¼‚æˆ–å–å
            myInfo-&gt;kp_proc.p_flag ^= P_TRACED;
        }
        return err;
    }
    return sysctl_p(name, namelen, info, infosize, newinfo, newinfosize);
}

+(void)load
{
    //äº¤æ¢
    rebind_symbols((struct rebinding[1])sysctl, 1);
}

@end
</code></pre>

<h2 id="3-ptracesysctlæå‰æ‰§è¡Œ">3. ptrace&amp;sysctlæå‰æ‰§è¡Œ</h2>

<ul>
  <li>æ–°å»ºçš„åŠ¨æ€åº“æ”¾åˆ°æœ€å‰é¢æ‰§è¡Œ</li>
  <li>åœ¨loadé‡Œé¢åˆ¤æ–­</li>
</ul>

<pre><code class="language-objective-c">#import "antiDebugCode.h"
#import "fishhook.h"
#import "MyPtraceHeader.h"
#import &lt;sys/sysctl.h&gt;

static dispatch_source_t timer;
@implementation antiDebugCode

void debugCheck(){
    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0.0 * NSEC_PER_SEC);
    dispatch_source_set_event_handler(timer, ^{
        if (isDebugger()) {
            NSLog(@"æ£€æµ‹åˆ°äº†!!");
        }else{
            NSLog(@"æ­£å¸¸!!");
        }
    });
    dispatch_resume(timer);
}

//æ£€æµ‹æ˜¯å¦è¢«è°ƒè¯•
BOOL isDebugger(){
    //æ§åˆ¶ç 
    int name[4];//é‡Œé¢æ”¾å­—èŠ‚ç .æŸ¥è¯¢ä¿¡æ¯
    name[0] = CTL_KERN;//å†…æ ¸æŸ¥çœ‹
    name[1] = KERN_PROC;//æŸ¥è¯¢è¿›ç¨‹
    name[2] = KERN_PROC_PID;//ä¼ é€’çš„å‚æ•°æ˜¯è¿›ç¨‹çš„ID(PID)
    name[3] = getpid();//PIDçš„å€¼å‘Šè¯‰
    
    struct kinfo_proc info;//æ¥å—è¿›ç¨‹æŸ¥è¯¢ç»“æœä¿¡æ¯çš„ç»“æ„ä½“
    size_t info_size = sizeof(info);//ç»“æ„ä½“çš„å¤§å°
    int error = sysctl(name, sizeof(name)/sizeof(*name), &amp;info, &amp;info_size, 0, 0);
    assert(error == 0);//0å°±æ˜¯æ²¡æœ‰é”™è¯¯,å…¶ä»–å°±æ˜¯é”™è¯¯ç 
    
    //1011 1000 1010 1010 1101 0101 1101 0101
    //&amp;
    //0000 0000 0000 1000 0000 0000 0000 0000
    // == 0 ? æ²¡æœ‰  æœ‰!!
    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);
}

void debugerCheck(){
    if (isDebugger()) {
        NSLog(@"è¿›ç¨‹è¢«è°ƒè¯•!!");
    }
    
    //å¼€å¯åè°ƒè¯•
    ptrace(PT_DENY_ATTACH, getpid(), 0, 0);
}

+(void)load
{
    debugerCheck();
}

@end
</code></pre>

<h2 id="4-æ”»é˜²åšå¼ˆæ‰¾åˆ°ä½ å°±èµ¢">4. æ”»é˜²åšå¼ˆï¼æ‰¾åˆ°ä½ å°±èµ¢</h2>

<ul>
  <li>loadCommandæ®µå‰ç§»â€¦</li>
  <li>ç›´æ¥ä¿®æ”¹äºŒè¿›åˆ¶ï¼Œæ”¹å˜ä»£ç </li>
  <li>ç›´æ¥é—ªé€€ï¼Œä¸¤ç§
    <ul>
      <li>exit</li>
      <li>ptrace</li>
    </ul>
  </li>
  <li>ä¸‹ä¸€ä¸ªç¬¦å·æ–­ç‚¹</li>
</ul>

<pre><code class="language-objective-c">//åªè¦è°ƒç”¨å°±å¯ä»¥æ–­ä½
ptrace
//btæŸ¥çœ‹å‡½æ•°çœŸå®ã€‚ç›¸å¯¹äºåŠ¨æ€åº“åç§»åœ°å€ã€‚æŒ‡ä»¤åœ°å€ï¼Œpcå¯„å­˜å™¨æ°¸è¿œæŒ‡å‘ä¸‹ä¸€æ¡
//image list æ‰¾åˆ°åŠ¨æ€åº“åœ°å€
//åç§»åœ°å€å‡å»åŠ¨æ€åº“åœ°å€ï¼Œæ‹¿åˆ°æŒ‡ä»¤åœ°å€
//hopperæŸ¥çœ‹ï¼ŒæŒ‡ä»¤åœ°å€çš„ä¸Šä¸€æ¡å³ä¸ºè°ƒç”¨åœ°å€
//å¯„å­˜å™¨å‰ä¸‰å¥(ä¿æŠ¤å¯„å­˜å™¨)ç›´æ¥è·³åˆ°åä¸‰å¥(æ¢å¤å¯„å­˜å™¨)ã€‚ä¸æ‰§è¡Œä¸­é—´option+Aä¿®æ”¹
//å¯¼å‡ºfile/Produce New Executable
//æ›¿æ¢Macho
</code></pre>

<h2 id="5-ç ´è§£æ‚¬ç–‘å·²ä¹…çš„åhook">5. ç ´è§£æ‚¬ç–‘å·²ä¹…çš„åHOOK</h2>

<ul>
  <li>hopperæŸ¥æ‰¾ method_setImplementation</li>
  <li>ç›´æ¥ä¿®æ”¹åœ°å€ï½ï½ï½</li>
</ul>

<pre><code class="language-objective-c">
</code></pre>

<pre><code class="language-objectivec">//æ‹¿åˆ°çš„åœ°å€
bt 
//æŸ¥çœ‹æ±‡ç¼–
dis -s åœ°å€ 
</code></pre>

:ET