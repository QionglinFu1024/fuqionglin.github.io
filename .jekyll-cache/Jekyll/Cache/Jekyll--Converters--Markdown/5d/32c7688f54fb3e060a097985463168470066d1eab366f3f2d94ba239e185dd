I"N†<h4 id="ä¸‰æ¬¡æ¡æ‰‹-å››æ¬¡æŒ¥æ‰‹">ä¸‰æ¬¡æ¡æ‰‹-å››æ¬¡æŒ¥æ‰‹</h4>

<ul>
  <li>http çš„ä¼ è¾“è¿‡ç¨‹
    <ul>
      <li>åŸŸå-&gt; ip</li>
      <li>http tcp ä¸‰æ¬¡æ¡æ‰‹</li>
      <li>ä¼ headæ•°æ®</li>
      <li>ä¼ ä¸€æ®µç©ºè¡Œ</li>
      <li>ä¼ bodyæ•°æ®</li>
    </ul>
  </li>
  <li>Serverå°è£… head+body
    <ul>
      <li>ä¼ head</li>
      <li>ä¼ ç©ºè¡Œ</li>
      <li>ä¼ body</li>
      <li>æ–­å¼€è¿æ¥  å››æ¬¡æŒ¥æ‰‹</li>
    </ul>
  </li>
</ul>

<h5 id="ä¸‰æ¬¡æ¡æ‰‹">ä¸‰æ¬¡æ¡æ‰‹</h5>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/13.jpg" alt="" /></p>

<ul>
  <li>
    <p>SYNï¼šåŒæ­¥åºåˆ—ç¼–å·ï¼ˆSynchronize Sequence Numbersï¼‰ã€‚
Clientå°†æ ‡å¿—ä½SYNç½®ä¸º1ï¼Œéšæœºäº§ç”Ÿä¸€ä¸ªå€¼seq=J
è¯¥åºåˆ—ç¼–å·ä¸ºTCPè¿æ¥åˆå§‹ç«¯(ä¸€èˆ¬æ˜¯å®¢æˆ·ç«¯)çš„åˆå§‹åºåˆ—ç¼–å·ã€‚åœ¨è¿™é‡Œï¼Œå¯ä»¥æŠŠTCPåºåˆ—ç¼–å·çœ‹ä½œæ˜¯ä¸€ä¸ªèŒƒå›´ä»0åˆ°4ï¼Œ294ï¼Œ967ï¼Œ295çš„32ä½è®¡æ•°å™¨ã€‚é€šè¿‡TCPè¿æ¥äº¤æ¢çš„æ•°æ®ä¸­æ¯ä¸€ä¸ªå­—èŠ‚éƒ½ç»è¿‡åºåˆ—ç¼–å·ã€‚åœ¨TCPæŠ¥å¤´ä¸­çš„åºåˆ—ç¼–å·æ åŒ…æ‹¬äº†TCPåˆ†æ®µä¸­ç¬¬ä¸€ä¸ªå­—èŠ‚çš„åºåˆ—ç¼–å·ã€‚</p>
  </li>
  <li>
    <p>ACKï¼šç¡®è®¤æ ‡å¿—,ç¡®è®¤ç¼–å·(Acknowledgement Number)æ æœ‰æ•ˆã€‚å¤§å¤šæ•°æƒ…å†µä¸‹è¯¥æ ‡å¿—ä½æ˜¯ç½®ä½çš„ã€‚TCPæŠ¥å¤´å†…çš„ç¡®è®¤ç¼–å·æ å†…åŒ…å«çš„ç¡®è®¤ç¼–å·(w+1ï¼ŒFigure-1)ä¸ºä¸‹ä¸€ä¸ªé¢„æœŸçš„åºåˆ—ç¼–å·ï¼ŒåŒæ—¶æç¤ºè¿œç«¯ç³»ç»Ÿå·²ç»æˆåŠŸæ¥æ”¶æ‰€æœ‰æ•°æ®ã€‚</p>
  </li>
</ul>

<h5 id="å››æ¬¡æŒ¥æ‰‹">å››æ¬¡æŒ¥æ‰‹</h5>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.jpg" alt="" /></p>

<h4 id="ipå¤´tcp-udpå¤´">ipå¤´TCP-UDPå¤´</h4>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/15.jpg" alt="" /></p>

<ul>
  <li>
    <p>ipè¡¨å¤´ï¼Œé€šå¸¸20ä¸ªå­—èŠ‚
<img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.jpg" alt="" /></p>
  </li>
  <li>TCPè¡¨ï¼Œä¿è¯å¯é æ€§</li>
  <li>
    <p>32ä½åºå·
<img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/18.jpg" alt="" /></p>
  </li>
  <li>
    <p>UDPï¼Œä¸å¯é 
<img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/19.jpg" alt="" /></p>
  </li>
  <li>åˆ†ç‰‡å¤„ç†
<img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/20.jpg" alt="" /></li>
</ul>

<h4 id="æ–­ç‚¹ç»­ä¼ ">æ–­ç‚¹ç»­ä¼ </h4>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
#import "KCDownloadNetwork.h"

typedef void (^KCRequestHandleBlock)(id result,NSString* msg, NSInteger errorCode);

@interface KCNetwork : NSObject

+ (instancetype)shared;

- (NSURLSessionDataTask *)post:(NSString*)url token:(NSString*)token reqData:(NSDictionary*)params handle:(KCRequestHandleBlock)handleblock;

@end
</code></pre>

<pre><code class="language-objectivec">#import "KCNetwork.h"

@interface KCNetwork()<NSURLSessionDelegate>

@property (nonatomic, copy) KCRequestHandleBlock handleBlock;
@property (nonatomic, strong) NSMutableData *receivedData;

@end

@implementation KCNetwork

+ (instancetype)shared{
    static KCNetwork *network;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        network = [[KCNetwork alloc] init];
    });
    return network;
}


- (NSURLSessionDataTask *)post:(NSString*)url token:(NSString*)token reqData:(NSDictionary*)params handle:(KCRequestHandleBlock)handleblock{
    
    // æ ¡éªŒurl
    if (!url || url.length == 0) {
        NSLog(@"url æ— æ•ˆ!");
        return nil;
    }
    // token
    if (!token || token.length == 0) {
        NSLog(@"token æ— æ•ˆ!");
        return nil;
    }
    
    // è®°å½•å›è°ƒ,åœ¨ä»»ä½•ä½ æƒ³è¦æ“ä½œçš„åœ°æ–¹,éšæ—¶æ‹¿å‡ºæ¥
    self.handleBlock = handleblock;
    
    // æ“ä½œURL
    NSURL *requestUrl = [NSURL URLWithString:url];
    // å®šä¹‰request æ¥è®¾å®šè¯·æ±‚å¤´ -- afn  resquestSerizetion nsset
    // https + ssl cer  token client
    // URL :  GET
    // post : è¯·æ±‚ä½“
    // httpbody --- httpStream afn
    
    NSMutableURLRequest *mRequest = [NSMutableURLRequest requestWithURL:requestUrl];
    [mRequest setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
    [mRequest setValue:token forHTTPHeaderField:@"token"];
    // è¯·æ±‚æ–¹æ³•
    mRequest.HTTPMethod = @"POST";
    /**
     åˆ«å›ç­” å‚æ•°åœ¨url åé¢æ‹¼æ¥äº†:
     post get æ ¹æœ¬åŒºåˆ«: æ•°æ®ä¿å­˜çš„ head VS body
     */
    // é»˜è®¤60ç§’
    mRequest.timeoutInterval = 30.0;
    
    // è¯·æ±‚ä½“å¤„ç†
    mRequest.HTTPBody = [[self convertToJSONData:params] dataUsingEncoding:NSUTF8StringEncoding];
    
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]
                                                          delegate:self
                                                     delegateQueue:[NSOperationQueue mainQueue]];
    
    // session --&gt; task : id
    //åˆ›å»ºè¯·æ±‚ Task è¯¥æ¬¡è¯·æ±‚çš„æŒ‡é’ˆ å¥æŸ„ *p  dataTask
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:mRequest];
    
    [dataTask resume];
    
    return dataTask;
    
}

#pragma mark -- NSURLSessionDataDelegate

// 1.æ¥æ”¶åˆ°æœåŠ¡å™¨çš„å“åº”
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {
    
    completionHandler(NSURLSessionResponseAllow);
}

// è¿”å›body å¤šæ¬¡è¿”å› ä¸ºä»€ä¹ˆ MTUé™åˆ¶  TCP åŒ…æŒ‰ç…§é¡ºåºè¿”å›
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
    
    [self.receivedData appendData:data];
    
}

// ä»»åŠ¡å®Œæˆæ—¶è°ƒç”¨æˆ–è€…å¤±è´¥
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    
    if(error == nil){
        NSString* jsonString =  [[NSString alloc] initWithData:self.receivedData  encoding:NSUTF8StringEncoding];
        id obj = [self dictionaryWithJsonString:jsonString];
        NSLog(@"%@",obj);
        self.handleBlock(obj, @"è¯·æ±‚æˆåŠŸ", 200);
    }else{
        self.handleBlock(nil,[self getErrCode:error.code],error.code);
    }
}



#pragma mark - é”™è¯¯ä»£ç 

-(NSString*)getErrCode:(NSInteger)code{
    
    switch (code) {
        case 700:
            return @"ä¼šè¯è¿‡æœŸ";
            break;
            
        case 800:
            return @"åå°ggæ­£å¸¸ç»´æŠ¤ä¸­";
            break;
            
        case 404:
            return @"ç½‘ç»œè¿æ¥å¤±è´¥";
            break;
            
        case 500:
            return @"æœåŠ¡å™¨æ‹’ç»è¯·æ±‚";
            break;
            
        default:
            break;
    }
    
    return @"æœªçŸ¥é”™è¯¯";
}

// json
#pragma mark - json åºåˆ—åŒ–
- (NSString*)convertToJSONData:(id)infoDict{
    NSError *error;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:infoDict
                                                       options:NSJSONWritingPrettyPrinted
                                                         error:&amp;error];
    NSString *jsonString = @"";
    if (!jsonData){
        NSLog(@"json åºåˆ—åŒ–é”™è¯¯: %@", error);
    }else{
        jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
    }
    
    jsonString = [jsonString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    //å»é™¤æ‰é¦–å°¾çš„ç©ºç™½å­—ç¬¦å’Œæ¢è¡Œå­—ç¬¦
    [jsonString stringByReplacingOccurrencesOfString:@"\n" withString:@""];
    return jsonString;
}

#pragma mark - json ååºåˆ—åŒ– -- json è§£æ
-(NSDictionary *)dictionaryWithJsonString:(NSString *)jsonString
{
    if (jsonString == nil) {
        return nil;
    }
    NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
    NSError *err;
    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData
                                                        options:NSJSONReadingMutableContainers
                                                          error:&amp;err];
    if(err){
        NSLog(@"jsonè§£æå¤±è´¥ï¼š%@",err);
        return nil;
    }
    return dic;
}

#pragma mark - lazy

- (NSMutableData *)receivedData{
    if (!_receivedData) {
        _receivedData = [NSMutableData data];
    }
    return _receivedData;
}

@end
&lt;/code&gt;&lt;/pre&gt;

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;

@protocol KCDownLoadDelegate <NSObject>
@optional
- (void)backDownprogress:(float)progress tag:(NSInteger)tag;
- (void)downSucceed:(NSURL*)url tag:(NSInteger)tag;
- (void)downError:(NSError*)error tag:(NSInteger)tag;
@end


@interface KCDownloadNetwork : NSObject

@property (nonatomic, strong) NSURLSession* session;
@property (nonatomic, strong) NSURLSessionDownloadTask* downloadTask;
@property (nonatomic, strong) NSData* resumeData;
@property (nonatomic, weak) id<KCDownLoadDelegate> myDeleate;
@property (nonatomic, assign) NSInteger tag;//æŸä¸ªæ–‡ä»¶ä¸‹è½½çš„çš„æ ‡è®°

-(void)downFile:(NSString*)fileUrl isBreakpoint:(BOOL)breakpoint;

//æš‚åœ ç»§ç»­ å–æ¶ˆ æ–‡ä»¶ä¸‹è½½
-(void)suspendDownload;
-(void)cancelDownload;

@end

&lt;/code&gt;&lt;/pre&gt;

<pre><code class="language-objectivec">#import "KCDownloadNetwork.h"
#import &lt;CommonCrypto/CommonDigest.h&gt;


@interface KCDownloadNetwork()<NSURLSessionDelegate>
@property (nonatomic) BOOL  mIsSuspend;
@property (nonatomic, copy) NSString* fileName;
@property (nonatomic, strong) NSData *myResumeData;

@end

@implementation KCDownloadNetwork

- (void)downFile:(NSString*)fileUrl isBreakpoint:(BOOL)breakpoint{
    
    if (!fileUrl || fileUrl.length == 0 || ![self checkIsUrlAtString:fileUrl]) {
        NSLog(@"fileUrl æ— æ•ˆ");
        return ;
    }
    
//    // åˆ¤æ–­ä¹‹å‰æ˜¯å¦å­˜åœ¨
//    // è¿™ä¸ªåœ°æ–¹æ˜¯ä¸æ˜¯å¯ä»¥å†™æˆå”¯ä¸€çš„åœ°å€
//    if ([[NSFileManager defaultManager] fileExistsAtPath:[self getTmpFileUrl]]) {
//        [self downloadWithResumeData];
//        return;
//    }
    
    NSURL *url = [NSURL URLWithString:fileUrl];

    if (!self.session) {
        
        //0.MD5 åŠ å¯†
        self.fileName = [self md5:fileUrl];
        
        //1.åˆ›å»ºNSURLSession,è®¾ç½®ä»£ç†
        NSURLSessionConfiguration *config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:[self currentDateStr]];
        // å…è®¸èœ‚çªç½‘ç»œ: ä½ å¯ä»¥åšåå¥½è®¾ç½®
        config.allowsCellularAccess = YES;
        config.timeoutIntervalForRequest = 30;
        //åˆ›å»ºä¸€ä¸ªä¸‹è½½çº¿ç¨‹
        self.session = [NSURLSession sessionWithConfiguration:config
                                                     delegate:self
                                                delegateQueue:[NSOperationQueue mainQueue]];
    }

    //2.åˆ›å»ºtask è¯·æ±‚å¥æŸ„
    if(breakpoint == NO){
        self.downloadTask = [self.session downloadTaskWithURL:url];
    }else{
        // æ–­ç‚¹ç»­ä¼ 
        [self downloadWithResumeData];
    }
    
    [self.downloadTask resume];
    
    [self saveTmpFile];
    
}


#pragma mark - NSURLSessionDelegate
//æ¯æ¬¡ä¼ ä¸€ä¸ªåŒ… è°ƒç”¨ä¸€æ¬¡è¯¥å‡½æ•° 512M
-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{

    float dowProgeress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
    if (self.myDeleate &amp;&amp; [self.myDeleate respondsToSelector:@selector(backDownprogress:tag:)]) {
        [self.myDeleate backDownprogress:dowProgeress tag:self.tag];
    }
    
}
/*
 2.ä¸‹è½½å®Œæˆä¹‹åè°ƒç”¨è¯¥æ–¹æ³•
 */
-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(nonnull NSURL *)location{

    NSLog(@"location == %@",location.path);
    
    //æ‹¼æ¥Doc æ›´æ¢çš„è·¯å¾„
    NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES) lastObject];
    NSString *file = [documentsPath stringByAppendingPathComponent:[NSString stringWithFormat:@"%@.mp4",self.fileName]];
    
    //åˆ›å»ºæ–‡ä»¶ç®¡ç†å™¨
    NSFileManager *manager = [NSFileManager defaultManager];
    if ([manager fileExistsAtPath: file]) {
        //å¦‚æœæ–‡ä»¶å¤¹ä¸‹æœ‰åŒåæ–‡ä»¶  åˆ™å°†å…¶åˆ é™¤
        [manager removeItemAtPath:file error:nil];
    }
    NSError *saveError;
    [manager moveItemAtURL:location toURL:[NSURL URLWithString:file] error:&amp;saveError];
    
    //å°†è§†é¢‘èµ„æºä»åŸæœ‰è·¯å¾„ç§»åŠ¨åˆ°è‡ªå·±æŒ‡å®šçš„è·¯å¾„
    BOOL success = [manager copyItemAtPath:location.path toPath:file error:nil];
    if (success) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSURL *url = [[NSURL alloc]initFileURLWithPath:file];
            if(self.myDeleate &amp;&amp; [self.myDeleate respondsToSelector:@selector(downSucceed:tag:)])
                [self.myDeleate downSucceed:url tag:self.tag];
        });
    }
    //å·²ç»æ‹·è´ åˆ é™¤ç¼“å­˜æ–‡ä»¶
    [manager removeItemAtPath:location.path error:nil];
    
    [manager removeItemAtPath:[self getTmpFileUrl] error:nil];
}

//ä¸‹è½½å¤±è´¥è°ƒç”¨
-(void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error{
    
    if(error &amp;&amp; self.myDeleate &amp;&amp; [self.myDeleate respondsToSelector:@selector(downError:tag:)] &amp;&amp; error.code != -999)
        [self.myDeleate downError:error tag:self.tag];
}

- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session{
    NSLog(@"æ‰€æœ‰åå°ä»»åŠ¡å·²ç»å®Œæˆ: %@",session.configuration.identifier);
    
}
    


#pragma mark - private

//æš‚åœä¸‹è½½
-(void)suspendDownload{
 
    if (self.mIsSuspend) {
        [self.downloadTask resume];
    }else{
        [self.downloadTask suspend];
    }
    self.mIsSuspend = !self.mIsSuspend;
}


//å–æ¶ˆä¸‹è½½
-(void)cancelDownload{
    
//    [self.downloadTask cancel];
    __weak typeof(self) weakSelf = self;
    [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) {
       
//        weakSelf.resumeData = resumeData;
        weakSelf.downloadTask  = nil;
        [resumeData writeToFile:[weakSelf getTmpFileUrl] atomically:NO];
    }];
    
    
}

//æ–­ç‚¹ä¸‹è½½
-(void)downloadWithResumeData{

    if (!self.session) {
        return;
    }
    
    NSData *data = nil;
    
    if (self.resumeData) {
        data = self.resumeData;
    }else{
        
        NSFileManager *fm = [NSFileManager defaultManager];
        NSData *datas     = [fm contentsAtPath:[self getTmpFileUrl]];
        NSString *fileStr = [[NSString alloc] initWithData:datas encoding:NSUTF8StringEncoding];
        
        NSLog(@"%@----%@",[self getTmpFileUrl],fileStr);
        data = datas;
    }
    
    self.downloadTask = [self.session downloadTaskWithResumeData:data];
}

//æœªä¸‹è½½å®Œçš„ä¸´æ—¶æ–‡ä»¶urlåœ°å€
-(NSString*)getTmpFileUrl{
    
    NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
    NSString *filePath = [docPath stringByAppendingPathComponent:@"download.tmp"];
    NSLog(@"%@",filePath);
    
//    NSString* url = [NSString stringWithFormat:@"/Users/LM/Desktop/%@.tmp",self.fileName];
    return filePath;
}

//æå‰ä¿å­˜ä¸´æ—¶æ–‡ä»¶ é¢„é˜²ä¸‹è½½ä¸­æ€æ‰app
//å¼€å¯å®šæ—¶å™¨
-(void)saveTmpFile{
    
    [NSTimer scheduledTimerWithTimeInterval:4 repeats:YES block:^(NSTimer * _Nonnull timer) {
       
        [self downloadTmpFile];
    }];

}

//æ€æ‰appå ä¸è‡³äºä¸‹è½½çš„éƒ¨åˆ†æ–‡ä»¶å…¨éƒ¨ä¸¢å¤±ï¼Œæ­»äº¡å¤„ç†
- (void)downloadTmpFile{
    __weak typeof(self) weakSelf = self;
    [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) {
        //å…ˆä¿å­˜
        weakSelf.resumeData = resumeData;
        weakSelf.downloadTask  = nil;
        [resumeData writeToFile:[weakSelf getTmpFileUrl] atomically:NO];
        //åœ¨ä¸‹è½½
        self.downloadTask =  [self.session downloadTaskWithResumeData:resumeData];
        [self.downloadTask resume];
    }];

    
}

//ç”¨urlè·å–æ–‡ä»¶åç§° MD5åŠ å¯†
- (NSString *)md5:(NSString *)string{
    const char *cStr = [string UTF8String];
    unsigned char digest[CC_MD5_DIGEST_LENGTH];
    
    CC_MD5(cStr, (CC_LONG)strlen(cStr), digest);
    
    NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
    for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) {
        [result appendFormat:@"%02X", digest[i]];
    }
    
    return result;
}

//è·å–å½“å‰æ—¶é—´ ä¸‹è½½idæ ‡è¯†ç”¨
- (NSString *)currentDateStr{
    NSDate *currentDate = [NSDate date];//è·å–å½“å‰æ—¶é—´ï¼Œæ—¥æœŸ
    NSTimeInterval timeInterval = [currentDate timeIntervalSince1970];
    return [NSString stringWithFormat:@"%.f",timeInterval];
}

- (BOOL)checkIsUrlAtString:(NSString *)url {
    NSString *pattern = @"http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?";
    
    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];
    NSArray *regexArray = [regex matchesInString:url options:0 range:NSMakeRange(0, url.length)];
    
    if (regexArray.count &gt; 0) {
        return YES;
    }else {
        return NO;
    }
}

- (void)dealloc
{
    [self.session invalidateAndCancel];
    self.session = nil;
    [self.downloadTask cancel];
    self.downloadTask = nil;
}



@end
&lt;/code&gt;&lt;/pre&gt;

<pre><code class="language-objectivec">#import "ViewController.h"
#import &lt;AVFoundation/AVFoundation.h&gt;
#import &lt;AVKit/AVKit.h&gt;
#import "KCNetwork.h"

@interface ViewController ()<KCDownLoadDelegate>

@property (weak, nonatomic) IBOutlet UIProgressView *progress;
@property (weak, nonatomic) IBOutlet UILabel *lab1;
@property (weak, nonatomic) IBOutlet UILabel *lab2;
@property (weak, nonatomic) IBOutlet UILabel *msgLab;

@property (weak, nonatomic) IBOutlet UILabel *proLab;

@property (nonatomic, strong) KCDownloadNetwork *fileDownloadNetwork;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}

- (IBAction)btnClick:(id)sender {
    
//    NSString *url = @"http://127.0.0.1:8080/static/123.mp4";
    NSString *url = @"http://m.lanlingfuli.com/aif/home/getRecomm";
    NSString *token = @"23134543223";
    NSDictionary *para = @{@"agency":@"ios",@"pageIndex":@"1"};

    // NSURLSession  ---&gt;  task  ---&gt;  id
    // tag  ---  indextify
    
    [[KCNetwork shared] post:url token:token reqData:para handle:^(id result, NSString *msg, NSInteger errorCode) {
        NSLog(@"%@",[NSThread currentThread]);
        if (errorCode == 200) {
            NSLog(@"result == %@",result);
        }else{
            
        }
    }];
    
    
}


//------------------------------å¤§æ–‡ä»¶ä¸‹è½½---------------------------------

// å¼€å§‹ä¸‹è½½
- (IBAction)startDown:(id)sender {
    [self downFile:NO];
}

// æ–­ç‚¹ç»­ä¼ 
- (IBAction)breakpointContinuingly:(id)sender {
    [self downFile:YES];
}


-(void)downFile:(BOOL)breakpoint{
    
    //172.16.127.104
    NSString *fileUrl = @"https://pic.ibaotu.com/00/48/71/79a888piCk9g.mp4";

    
    if(self.fileDownloadNetwork == nil){
        self.fileDownloadNetwork = [KCDownloadNetwork new];
        self.fileDownloadNetwork.tag = 1; // åŒºåˆ« ä¸åŒçš„ä»»åŠ¡ä¸‹è½½ç±»å‹
        self.fileDownloadNetwork.myDeleate = self;
        //ç¬¬äºŒä¸ªå‚æ•° éœ€è¦é‡æ–°ä¸‹è½½è¿˜æ˜¯æ¥ç€ä¸Šæ¬¡çš„ä¸‹è½½
    }
    
    // ç¬¬ä¸€æ¬¡ : æ²¡æœ‰æ–‡ä»¶
    // æ–­ç‚¹  :  ä¸´æ—¶æ–‡ä»¶
    [self.fileDownloadNetwork downFile:fileUrl isBreakpoint:breakpoint];

}

//æš‚åœä¸‹è½½
- (IBAction)suspendedDown:(id)sender {
    [self.fileDownloadNetwork suspendDownload];
}
//å–æ¶ˆä¸‹è½½
- (IBAction)cancelDown:(id)sender {
    [self.fileDownloadNetwork cancelDownload];
}



//è¿›åº¦è¿”å›   æ¯ä¸€ä¸ªæ•°æ®åŒ…å›æ¥è°ƒç”¨ä¸€æ¬¡
- (void)backDownprogress:(float)progress tag:(NSInteger)tag{
    
    self.progress.progress = progress;
    self.proLab.text = [NSString stringWithFormat:@"%0.1f%@",progress*100,@"%"];
}

//ä¸‹è½½æˆåŠŸ
- (void)downSucceed:(NSURL*)url tag:(NSInteger)tag{
    NSLog(@"ä¸‹è½½æˆåŠŸ,å‡†å¤‡æ’­æ”¾");
    [self paly: url];
    self.progress.progress = 0;
    self.proLab.text = @"0.0%";
    self.fileDownloadNetwork = nil;
}

//ä¸‹è½½å¤±è´¥
- (void)downError:(NSError*)error tag:(NSInteger)tag{
    
    self.fileDownloadNetwork = nil;
    self.progress.progress = 0;
    self.proLab.text = @"0.0%";
    NSLog(@"ä¸‹è½½å¤±è´¥,è¯·å†æ¬¡ä¸‹è½½ :%@",error);
}



//ä¼ å…¥æœ¬åœ°url è¿›è¡Œè§†é¢‘æ’­æ”¾
-(void)paly:(NSURL*)playUrl{
    
    //ç³»ç»Ÿçš„è§†é¢‘æ’­æ”¾å™¨
    AVPlayerViewController *controller = [[AVPlayerViewController alloc]init];
    //æ’­æ”¾å™¨çš„æ’­æ”¾ç±»
    AVPlayer * player = [[AVPlayer alloc]initWithURL:playUrl];
    controller.player = player;
    //è‡ªåŠ¨å¼€å§‹æ’­æ”¾
    [controller.player play];
    //æ¨å‡ºè§†å±æ’­æ”¾å™¨
    [self  presentViewController:controller animated:YES completion:nil];
}

@end
&lt;/code&gt;&lt;/pre&gt;

<pre><code class="language-objectivec">#import "AppDelegate.h"

@interface AppDelegate ()
@property (nonatomic, copy) NSString *identifier;

@end

@implementation AppDelegate



- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)(void))completionHandler{
    
    self.identifier = identifier;
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
    // Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.
    NSLog(@"å·²ç»ä¸‹è½½å¥½äº†: %@",self.identifier);

}



- (void)applicationWillTerminate:(UIApplication *)application {
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
    
    NSLog(@"ç¨‹åºè¢«æ€æ­»ï¼ŒapplicationWillTerminate");

}


@end
</code></pre>

#### æ–‡ä»¶æµå¤„ç†

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
#import &lt;UIKit/UIKit.h&gt;

typedef void (^KCFileHandleBlock)(NSURL* fileUrl, NSString *progress);

@interface KCFileStreamNetwork : NSObject

- (NSURLSessionDataTask*)getDownFileUrl:(NSString*)fileUrl backBlock:(KCFileHandleBlock)handleBlock;
@property(nonatomic,strong)UILabel *proLab;

@end
</code></pre>

<pre><code class="language-objectivec">#import "KCFileStreamNetwork.h"

@interface KCFileStreamNetwork()<NSURLSessionDelegate>

@property (nonatomic, copy) KCFileHandleBlock handleBlock;
@property (nonatomic, copy) NSString *mFileUrl;
@property (nonatomic, strong) NSMutableData *receiveData;
@property (nonatomic, strong) NSOutputStream *outpustream;
@property (nonatomic, strong) NSFileHandle *fileHandle;


@end

@implementation KCFileStreamNetwork

- (instancetype)init {
    
    if(self=[super init]){
        _receiveData = [[NSMutableData alloc] init];
        return self;
    }
    return nil;
}

- (NSURLSessionDataTask*)getDownFileUrl:(NSString*)fileUrl backBlock:(KCFileHandleBlock)handleBlock{
    
    if(fileUrl==nil || handleBlock==nil)  return nil;
    
    self.handleBlock = handleBlock;
    //ç¡®å®šè¯·æ±‚è·¯å¾„
    NSURL *url0 = [NSURL URLWithString:fileUrl];
    //åˆ›å»ºå¯å˜è¯·æ±‚å¯¹è±¡
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url0];
    request.HTTPMethod = @"GET";
    request.timeoutInterval = 30.0;
    
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]
                                                          delegate:self
                                                     delegateQueue:[NSOperationQueue   mainQueue]];
    
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request];
    //å‘é€è¯·æ±‚
    [dataTask resume];
    
    return dataTask;
    
}


NSInteger fileDownPro = 0;
NSInteger fileTotalPro = 0;
#pragma mark -- NSURLSessionDataDelegate// 1.æ¥æ”¶åˆ°æœåŠ¡å™¨çš„å“åº”
//æ¥å—çš„httpçš„ headæ•°æ®
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {
    
    fileTotalPro = response.expectedContentLength;//å­—èŠ‚
    completionHandler(NSURLSessionResponseAllow);
}

// 2.æ¥æ”¶åˆ°http çš„bodyæ•°æ®
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
    
    //è¿™æ ·ä¼šé€ æˆå†…å­˜æš´å¢
    //[self.receiveData appendData:data];
    
    //åˆ›å»ºæµï¼Œappendä¸ºYESçš„è¯ï¼Œæ¯æ¬¡å†™å…¥éƒ½æ˜¯è¿½åŠ åˆ°æ–‡ä»¶å°¾éƒ¨
    self.outpustream = [NSOutputStream outputStreamToFileAtPath:[self getSaveFilePath] append:YES];

    //ä¸€ç‚¹ä¸€ç‚¹çš„å­˜ ç»†æ°´æµé•¿
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
//        [self saveFile:data];
        [self.outpustream open];
        [self.outpustream write:data.bytes maxLength:data.length];
        [self.outpustream close];
    });
    
    fileDownPro  = fileDownPro +  data.length;
    float downPro = fileDownPro/(fileTotalPro*1.0)*100;
    NSString *progress = [NSString stringWithFormat:@"%.2f%@",downPro,@"%"];
    self.handleBlock(nil, progress);
}

// 3.3.ä»»åŠ¡å®Œæˆæ—¶è°ƒç”¨
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    
    NSLog(@"ä¸‹è½½å®Œæˆ");
    
    if (!error) {
//        [self.receiveData writeToFile:[self getSaveFilePath] atomically:YES];
    }
}

- (void)saveFile:(NSData *)data {
    //ä¿å­˜æ–‡ä»¶çš„è·¯å¾„
    NSString *filePath = [self getSaveFilePath];
    //å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›çš„æ˜¯nil
    NSFileHandle *fileHandle = [NSFileHandle fileHandleForWritingAtPath:filePath];
    //åˆ¤æ–­æ–‡ä»¶å­˜ä¸å­˜åœ¨
    if (fileHandle == nil) {
        //å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œä¼šè‡ªåŠ¨åˆ›å»º
        [data writeToFile:filePath atomically:YES];
    }else {
        //è®©offsetæŒ‡å‘æ–‡ä»¶çš„æœ«å°¾
        [fileHandle seekToEndOfFile];
        //åœ¨æ–‡ä»¶çš„æœ«å°¾å†ç»§ç»­å†™å…¥æ–‡ä»¶
        [fileHandle writeData:data];
        // åŒæ­¥ä¸€ä¸‹é˜²æ­¢æ“ä½œæ··ä¹±
        [fileHandle synchronizeFile];
        //å…³é—­æ–‡ä»¶
        [fileHandle closeFile];
    }
}

- (NSString *)getSaveFilePath{
    
    NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"video.mp4"];
    if (![[NSFileManager defaultManager] fileExistsAtPath:filePath]) {
        [[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil];
    }
    return filePath;
}


@end
&lt;/code&gt;&lt;/pre&gt;

<pre><code class="language-objectivec">#import "ViewController.h"
#import "KCFileStreamNetwork.h"

@interface ViewController ()
@property (weak, nonatomic) IBOutlet UILabel *progressLabel;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}


//æ–‡ä»¶æµä¸‹è½½
- (IBAction)fileSteamBtn:(id)sender {
    
    __weak typeof(self) weakSelf = self;
    
    KCFileStreamNetwork *fileStream = [KCFileStreamNetwork new];
    [fileStream  getDownFileUrl:@"https://pic.ibaotu.com/00/48/71/79a888piCk9g.mp4" backBlock:^(NSURL *fileUrl,NSString *progress) {
        weakSelf.progressLabel.text = progress;
        if (fileUrl) {
            NSLog(@"æ–‡ä»¶è·¯å¾„:%@",[fileUrl absoluteString]);
        }
    }];
    
}

- (IBAction)editFileBtn:(id)sender {
    
    NSString* filePath =  @"/Users/LM/Desktop/data.txt";
    NSFileManager* fm = [NSFileManager defaultManager];
    NSData* fileData =  [fm contentsAtPath:filePath];
    
    NSFileHandle *fielHandle = [NSFileHandle fileHandleForUpdatingAtPath:filePath];
    //[fielHandle seekToFileOffset:2];
    [fielHandle seekToEndOfFile];
    NSString *str = @"ä½ å¥½";
    NSData* stringData = [str dataUsingEncoding:NSUTF8StringEncoding];
    
    [fielHandle writeData:stringData];
    [fielHandle closeFile];
    
}

@end
</code></pre>




#### ç½‘ç»œæŠ“åŒ…

* è¯·æ±‚æ ¼å¼
    ![](https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/%E6%BD%AD%E5%B7%9E/%E5%A4%9A%E7%BA%BF%E7%A8%8B/12.jpg)

<pre><code class="language-objectivec">#import "KCNetwork.h"

typedef void (^KCRequestHandleBlock)(id result,NSString* msg, NSInteger errorCode);

@interface KCNetwork()<NSURLSessionDelegate>

@property (nonatomic, copy) KCRequestHandleBlock handleBlock;
@property (nonatomic, strong) NSMutableData *receivedData;

@end

@implementation KCNetwork

+ (instancetype)shared{
    static KCNetwork *network;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        network = [[KCNetwork alloc] init];
    });
    return network;
}


- (NSURLSessionDataTask *)post:(NSString*)url token:(NSString*)token reqData:(NSDictionary*)params handle:(KCRequestHandleBlock)handleblock{
    
    // æ ¡éªŒurl
    if (!url || url.length == 0) {
        NSLog(@"url æ— æ•ˆ!");
        return nil;
    }
    // token
    if (!token || token.length == 0) {
        NSLog(@"token æ— æ•ˆ!");
        return nil;
    }
    // è®°å½•å›è°ƒ,åœ¨ä»»ä½•ä½ æƒ³è¦æ“ä½œçš„åœ°æ–¹,éšæ—¶æ‹¿å‡ºæ¥
    self.handleBlock = handleblock;
    
    // æ“ä½œURL
    NSURL *requestUrl = [NSURL URLWithString:url];
    // å®šä¹‰request æ¥è®¾å®šè¯·æ±‚å¤´
    NSMutableURLRequest *mRequest = [NSMutableURLRequest requestWithURL:requestUrl];
    [mRequest setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
    [mRequest setValue:token forHTTPHeaderField:@"token"];
    // è¯·æ±‚æ–¹æ³•
    mRequest.HTTPMethod = @"POST";
    /**
     åˆ«å›ç­” å‚æ•°åœ¨url åé¢æ‹¼æ¥äº†:
     post get æ ¹æœ¬åŒºåˆ«: æ•°æ®ä¿å­˜çš„ head VS body
     */
    // é»˜è®¤60ç§’
    mRequest.timeoutInterval = 30.0;
    
    // è¯·æ±‚ä½“å¤„ç†
    mRequest.HTTPBody = [[self convertToJSONData:params] dataUsingEncoding:NSUTF8StringEncoding];
    
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]
                                                          delegate:self
                                                     delegateQueue:[NSOperationQueue mainQueue]];
    
    //åˆ›å»ºè¯·æ±‚ Task è¯¥æ¬¡è¯·æ±‚çš„æŒ‡é’ˆ å¥æŸ„ *p  dataTask
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:mRequest];
    
    [dataTask resume];
    
    return dataTask;
    
}

#pragma mark -- NSURLSessionDataDelegate

// 1.æ¥æ”¶åˆ°æœåŠ¡å™¨çš„å“åº”
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {
    
    completionHandler(NSURLSessionResponseAllow);
}

// è¿”å›body å¤šæ¬¡è¿”å› ä¸ºä»€ä¹ˆ MTUé™åˆ¶  TCP åŒ…æŒ‰ç…§é¡ºåºè¿”å›
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
    
    [self.receivedData appendData:data];
    
}

// ä»»åŠ¡å®Œæˆæ—¶è°ƒç”¨æˆ–è€…å¤±è´¥
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    
    if(error == nil){
        NSString* jsonString =  [[NSString alloc] initWithData:self.receivedData  encoding:NSUTF8StringEncoding];
        id obj = [self dictionaryWithJsonString:jsonString];
        NSLog(@"%@",obj);
        self.handleBlock(obj, @"è¯·æ±‚æˆåŠŸ", 200);
    }else{
        self.handleBlock(nil,[self getErrCode:error.code],error.code);
    }
}



#pragma mark - é”™è¯¯ä»£ç 

-(NSString*)getErrCode:(NSInteger)code{
    
    switch (code) {
        case 700:
            return @"ä¼šè¯è¿‡æœŸ";
            break;
            
        case 800:
            return @"åå°ggæ­£å¸¸ç»´æŠ¤ä¸­";
            break;
            
        case 404:
            return @"ç½‘ç»œè¿æ¥å¤±è´¥";
            break;
            
        case 500:
            return @"æœåŠ¡å™¨æ‹’ç»è¯·æ±‚";
            break;
            
        default:
            break;
    }
    
    return @"æœªçŸ¥é”™è¯¯";
}

#pragma mark - json åºåˆ—åŒ–
- (NSString*)convertToJSONData:(id)infoDict{
    NSError *error;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:infoDict
                                                       options:NSJSONWritingPrettyPrinted
                                                         error:&amp;error];
    NSString *jsonString = @"";
    if (!jsonData){
        NSLog(@"json åºåˆ—åŒ–é”™è¯¯: %@", error);
    }else{
        jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
    }
    
    jsonString = [jsonString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    //å»é™¤æ‰é¦–å°¾çš„ç©ºç™½å­—ç¬¦å’Œæ¢è¡Œå­—ç¬¦
    [jsonString stringByReplacingOccurrencesOfString:@"\n" withString:@""];
    return jsonString;
}

#pragma mark - json ååºåˆ—åŒ– -- json è§£æ
-(NSDictionary *)dictionaryWithJsonString:(NSString *)jsonString
{
    if (jsonString == nil) {
        return nil;
    }
    NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
    NSError *err;
    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData
                                                        options:NSJSONReadingMutableContainers
                                                          error:&amp;err];
    if(err){
        NSLog(@"jsonè§£æå¤±è´¥ï¼š%@",err);
        return nil;
    }
    return dic;
}

#pragma mark - lazy

- (NSMutableData *)receivedData{
    if (!_receivedData) {
        _receivedData = [NSMutableData data];
    }
    return _receivedData;
}

@end
&lt;/code&gt;&lt;/pre&gt;



</NSURLSessionDelegate></code></pre></NSURLSessionDelegate></code></pre></KCDownLoadDelegate></code></pre></NSURLSessionDelegate></code></pre></KCDownLoadDelegate></NSObject></code></pre></NSURLSessionDelegate></code></pre>
:ET