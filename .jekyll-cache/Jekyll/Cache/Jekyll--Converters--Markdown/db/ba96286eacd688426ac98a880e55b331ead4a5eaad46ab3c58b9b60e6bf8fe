I"<h3 id="泛型generics">泛型(Generics)</h3>

<ul>
  <li>泛型可以将类型参数化，提高代码复用率，减少代码量</li>
  <li>泛型函数赋值给变量</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func swapValues&lt;T&gt;(_ a: inout T, _ b: inout T) {
    (a, b) = (b, a)
}

func test&lt;T1, T2&gt;(_ t1: T1, _ t2: T2) {}
var fn: (Int, Double) -&gt; () = test

var i1 = 10
var i2 = 20
swapValues(&amp;i1, &amp;i2)

var d1 = 10.0
var d2 = 20.0
swapValues(&amp;d1, &amp;d2)

struct Date {
    var year = 0, month = 0, day = 0
}

var dd1 = Date(year: 2011, month: 9, day: 10)
var dd2 = Date(year: 2012, month: 10, day: 11)
swapValues(&amp;dd1, &amp;dd2)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Stack&lt;E&gt; {
    var elements = [E]()
    func push(_ element: E) { elements.append(element) }
    func pop() -&gt; E { elements.removeLast() }
    func top() -&gt; E { elements.last! }
    func size() -&gt; Int { elements.count }
}

class SubStack&lt;E&gt; : Stack&lt;E&gt; {}

struct Stack&lt;E&gt; {
    var elements = [E]()
    mutating func push(_ element: E) { elements.append(element) }
    mutating func pop() -&gt; E { elements.removeLast() }
    func top() -&gt; E { elements.last! }
    func size() -&gt; Int { elements.count }
}

var stack = Stack&lt;Int&gt;()
stack.push(11)
stack.push(22)
stack.push(33)
print(stack.top()) // 33
print(stack.pop()) // 33
print(stack.pop()) // 22
print(stack.pop()) // 11
print(stack.size()) // 0


enum Score&lt;T&gt; {
    case point(T)
    case grade(String)
}
let score0 = Score&lt;Int&gt;.point(100)
let score1 = Score.point(99)
let score2 = Score.point(99.5)
let score3 = Score&lt;Int&gt;.grade("A")
</code></pre></div></div>

<hr />

<h3 id="关联类型associated-type">关联类型(Associated Type)</h3>

<ul>
  <li>关联类型的作用:给协议中用到的类型定义一个占位名称</li>
  <li>协议中可以拥有多个关联类型</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Stackable {
    associatedtype Element // 关联类型
    mutating func push(_ element: Element)
    mutating func pop() -&gt; Element
    func top() -&gt; Element
    func size() -&gt; Int
}

class Stack&lt;E&gt; : Stackable {
    // typealias Element = E
    var elements = [E]()
    func push(_ element: E) {
        elements.append(element)
    }
    func pop() -&gt; E { elements.removeLast() }
    func top() -&gt; E { elements.last! }
    func size() -&gt; Int { elements.count }
}

class StringStack : Stackable {
    // 给关联类型设定真实类型
    // typealias Element = String
    var elements = [String]()
    func push(_ element: String) { elements.append(element) }
    func pop() -&gt; String { elements.removeLast() }
    func top() -&gt; String { elements.last! }
    func size() -&gt; Int { elements.count }
}
var ss = StringStack()
ss.push("Jack")
ss.push("Rose")
</code></pre></div></div>

<hr />

<h3 id="类型约束">类型约束</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Runnable { }
class Person { }
func swapValues&lt;T : Person &amp; Runnable&gt;(_ a: inout T, _ b: inout T) {
    (a, b) = (b, a)
}

protocol Stackable {
    associatedtype Element: Equatable
}
class Stack&lt;E : Equatable&gt; : Stackable { typealias Element = E }

func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool
    where S1.Element == S2.Element, S1.Element : Hashable {
        return false
}

var stack1 = Stack&lt;Int&gt;()
var stack2 = Stack&lt;String&gt;()
// error: requires the types 'Int' and 'String' be equivalent
equal(stack1, stack2)
</code></pre></div></div>

<hr />

<h3 id="协议类型的注意点">协议类型的注意点</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Runnable {}
class Person : Runnable {}
class Car : Runnable {}
func get(_ type: Int) -&gt; Runnable {
    if type == 0 {
        return Person()
    }
    return Car()
}

var r1 = get(0)
var r2 = get(1)
</code></pre></div></div>

<ul>
  <li>如果协议中有associatedtype</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Runnable {
    associatedtype Speed
    var speed: Speed { get }
}
class Person : Runnable {
    var speed: Double { 0.0 }
}
class Car : Runnable {
    var speed: Int { 0 }
}
</code></pre></div></div>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000032.jpg" alt="" /></p>

<hr />

<h3 id="泛型解决">泛型解决</h3>

<ul>
  <li>解决方案1⃣️：使用泛型</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func get&lt;T : Runnable&gt;(_ type: Int) -&gt; T {
    if type == 0 {
        return Person() as! T
    }
    return Car() as! T
}
var r1: Person = get(0)
var r2: Car = get(1)
</code></pre></div></div>

<hr />

<h3 id="不透明类型opaque-type">不透明类型(Opaque Type)</h3>

<ul>
  <li>解决方案2⃣️：使用<code class="language-plaintext highlighter-rouge">some</code>关键字声明一个不透明类型</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func get(_ type: Int) -&gt; some Runnable { Car() }
var r1 = get(0)
var r2 = get(1)
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">some</code>限制只能返回一种类型</li>
</ul>

<hr />

<h3 id="some">some</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">some</code>除了用在返回值类型上，一般还可以用在属性类型上</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Runnable { associatedtype Speed }
class Dog : Runnable { typealias Speed = Double }
class Person {
    var pet: some Runnable {
        return Dog()
    }
}
</code></pre></div></div>

<hr />

<h3 id="可选项的本质">可选项的本质</h3>

<ul>
  <li>可选项的本质是<code class="language-plaintext highlighter-rouge">enum</code>类型</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral {
    case none
    case some(Wrapped)
    public init(_ some: Wrapped)
}

var age: Int? = 10
var age0: Optional&lt;Int&gt; = Optional&lt;Int&gt;.some(10)
var age1: Optional = .some(10)
var age2 = Optional.some(10)
var age3 = Optional(10)
age = nil
age3 = .none

var age: Int? = nil
var age0 = Optional&lt;Int&gt;.none
var age1: Optional&lt;Int&gt; = .none

var age: Int? = .none
age = 10
age = .some(20)
age = nil

switch age {
case let v?:
    print("some", v)
case nil:
    print("none")
}

switch age {
case let .some(v):
    print("some", v)
case .none:
    print("none")
}


var age_: Int? = 10
var age: Int?? = age_
age = nil

var age0 = Optional.some(Optional.some(10))
age0 = .none
var age1: Optional&lt;Optional&gt; = .some(.some(10))
age1 = .none

var age: Int?? = 10
var age0: Optional&lt;Optional&gt; = 10
</code></pre></div></div>

<ul>
  <li></li>
</ul>

:ET