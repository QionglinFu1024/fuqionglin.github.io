I"'<h3 id="初始化器">初始化器</h3>

<ul>
  <li>类、结构体、枚举都可以定义初始化器</li>
  <li>类有2种初始化器:指定初始化器(designated initializer)、便捷初始化器(convenience initializer)</li>
  <li>每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器</li>
  <li>默认初始化器总是类的指定初始化器</li>
  <li>类偏向于少量指定初始化器，一个类通常只有一个指定初始化器</li>
  <li>初始化器的相互调用规则
    <ul>
      <li>指定初始化器必须从它的直系父类调用指定初始化器</li>
      <li>便捷初始化器必须从相同的类里调用另一个初始化器</li>
      <li>便捷初始化器最终必须调用一个指定初始化器</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 指定初始化器
init(parameters) {
    statements
}
// 便捷初始化器
convenience init(parameters) {
    statements
}
</code></pre></div></div>

<hr />

<h3 id="初始化器的相互调用">初始化器的相互调用</h3>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000030.jpg" alt="" /></p>

<hr />

<h3 id="两段式初始化">两段式初始化</h3>

<ul>
  <li>Swift在编码安全方面是煞费苦心，为了保证初始化过程的安全，设定了<strong>两段式初始化、 安全检查</strong></li>
  <li>两段式初始化
    <ul>
      <li>第1阶段:初始化所有存储属性
        <ul>
          <li>外层调用指定\便捷初始化器</li>
          <li>分配内存给实例，但未初始化</li>
          <li>指定初始化器确保当前类定义的存储属性都初始化</li>
          <li>指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链</li>
        </ul>
      </li>
      <li>第2阶段:设置新的存储属性值
        <ul>
          <li>从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例</li>
          <li>初始化器现在能够使用<code class="language-plaintext highlighter-rouge">self</code>(访问、修改它的属性，调用它的实例方法等等)</li>
          <li>最终，链中任何便捷初始化器都有机会定制实例以及使用<code class="language-plaintext highlighter-rouge">self</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="安全检查">安全检查</h3>

<ul>
  <li>指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成</li>
  <li>指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值</li>
  <li>便捷初始化器必须先调用同类中的其它初始化器，然后再为任意属性设置新值</li>
  <li>初始化器在第1阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用self</li>
  <li>直到第1阶段结束，实例才算完全合法</li>
</ul>

<hr />

<h3 id="重写">重写</h3>

<ul>
  <li>当重写父类的指定初始化器时，必须加上<code class="language-plaintext highlighter-rouge">override</code>(即使子类的实现是便捷初始化器)</li>
  <li>如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上<code class="language-plaintext highlighter-rouge">override</code>
    <ul>
      <li>因为父类的便捷初始化器永远不会通过子类直接调用，因此，严格来说，子类无法重写父类的便捷初始化器</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="自动继承">自动继承</h3>

<ol>
  <li>如果子类没有自定义任何指定初始化器，它会自动继承父类所有的指定初始化器</li>
  <li>如果子类提供了父类所有指定初始化器的实现(要么通过方式1继承，要么重写)
    <ul>
      <li>子类自动继承所有的父类便捷初始化器</li>
    </ul>
  </li>
  <li>就算子类添加了更多的便捷初始化器，这些规则仍然适用</li>
  <li>子类以便捷初始化器的形式重写父类的指定初始化器，也可以作为满足规则2的一部分</li>
</ol>

<hr />

<h3 id="required">required</h3>

<ul>
  <li>用<code class="language-plaintext highlighter-rouge">required</code>修饰指定初始化器，表明其所有子类都必须实现该初始化器(通过继承或者重写实现)</li>
  <li>如果子类重写了<code class="language-plaintext highlighter-rouge">required</code>初始化器，也必须加上<code class="language-plaintext highlighter-rouge">required</code>，不用加<code class="language-plaintext highlighter-rouge">override</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class Person {
    required init() { }
    init(age: Int) { }
}

class Student : Person {
    required init() {
        super.init() }
}
</code></pre></div></div>

<hr />

<h3 id="属性观察器">属性观察器</h3>

<ul>
  <li>父类的属性在它自己的初始化器中赋值不会触发属性观察器，但在子类的初始化器中赋值会触发属性观察器</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Person {
    var age: Int {
        willSet {
            print("willSet", newValue)
        }
        didSet {
            print("didSet", oldValue, age)
        }
    }
    init() {
        self.age = 0
    }
}

class Student : Person {
    override init() {
        super.init()
        self.age = 1
    }
}

// willSet 1
// didSet 0 1
var stu = Student()
</code></pre></div></div>

<hr />

<h3 id="可失败初始化器">可失败初始化器</h3>

<ul>
  <li>类、结构体、枚举都可以使用<code class="language-plaintext highlighter-rouge">init?</code>定义可失败初始化器</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Person {
    var name: String
    init?(name: String) {
        if name.isEmpty {
            return nil
        }
        self.name = name
    }
}
</code></pre></div></div>

<ul>
  <li>不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器</li>
  <li>可以用<code class="language-plaintext highlighter-rouge">init!</code>定义隐式解包的可失败初始化器</li>
  <li>可失败初始化器可以调用非可失败初始化器，非可失败初始化器调用可失败初始化器需要进行解包</li>
  <li>如果初始化器调用一个可失败初始化器导致初始化失败，那么整个初始化过程都失败，并且之后的代码都停止执行</li>
  <li>可以用一个非可失败初始化器重写一个可失败初始化器，但反过来是不行的</li>
  <li>之前接触过的可失败初始化器</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var num = Int("123")
public init?(_ description: String)

enum Answer : Int {
    case wrong, right
}
var an = Answer(rawValue: 1)
</code></pre></div></div>

<hr />

<h3 id="反初始化器deinit">反初始化器(deinit)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">deinit</code>叫做反初始化器，类似于C++的析构函数、OC中的dealloc方法
    <ul>
      <li>当类的实例对象被释放内存时，就会调用实例对象的<code class="language-plaintext highlighter-rouge">deinit</code>方法</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Person {
    deinit {
        print("Person对象销毁了")
    }
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">deinit</code>不接受任何参数，不能写小括号，不能自行调用</li>
  <li>父类的<code class="language-plaintext highlighter-rouge">deinit</code>能被子类继承</li>
  <li>子类的<code class="language-plaintext highlighter-rouge">deinit</code>实现执行完毕后会调用父类的<code class="language-plaintext highlighter-rouge">deinit</code></li>
</ul>

<hr />

<h3 id="可选链optional-chaining">可选链(Optional Chaining)</h3>

<ul>
  <li>如果可选项为nil，调用方法、下标、属性失败，结果为nil</li>
  <li>如果可选项不为nil，调用方法、下标、属性成功，结果会被包装成可选项
    <ul>
      <li>如果结果本来就是可选项，不会进行再次包装</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Car { var price = 0 }
class Dog { var weight = 0 }
class Person {
    var name: String = ""
    var dog: Dog = Dog()
    var car: Car? = Car()
    func age() -&gt; Int { 18 }
    func eat() { print("Person eat") }
    subscript(index: Int) -&gt; Int { index }
}

if let _ = person?.eat() { // ()?
    print("eat调用成功")
} else {
    print("eat调用失败")
}

var person: Person? = Person()
var age1 = person!.age() // Int
var age2 = person?.age() // Int?
var name = person?.name // String?
var index = person?[6] // Int?
 func getName() -&gt; String { "jack" }
// 如果person是nil，不会调用getName()
person?.name = getName()
</code></pre></div></div>

<ul>
  <li>多个?可以链接在一起
    <ul>
      <li>如果链中任何一个节点是nil，那么整个链就会调用失败</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var dog = person?.dog // Dog?
var weight = person?.dog.weight // Int?
var price = person?.car?.price // Int?

var scores = ["Jack": [86, 82, 84], "Rose": [79, 94, 81]]
scores["Jack"]?[0] = 100
scores["Rose"]?[2] += 10
scores["Kate"]?[0] = 88

var num1: Int? = 5
num1? = 10 // Optional(10)

var num2: Int? = nil
num2? = 10 // nil

var dict: [String : (Int, Int) -&gt; Int] = [
    "sum" : (+),
    "difference" : (-)
]
var result = dict["sum"]?(10, 20) // Optional(30), Int?
</code></pre></div></div>

:ET