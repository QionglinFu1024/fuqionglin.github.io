I"+=<h3 id="swift版本">Swift版本</h3>

<ul>
  <li>历时5年发展，从Swift1.x发展到了Swift5.x版本，经历了多次重大改变，ABI终于稳定
    <ul>
      <li>API(Application Programming Interface):应用程序编程接口
        <ul>
          <li>源代码和库之间的接口</li>
        </ul>
      </li>
      <li>ABI(Application Binary Interface):应用程序二进制接口
        <ul>
          <li>
            <p>应用程序与操作系统之间的底层接口</p>
          </li>
          <li>
            <p>涉及的内容有:目标文件格式、数据类型的大小\布局\对齐、函数调用约定等等</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>随着ABI的稳定，Swift语法基本不会再有太大的变动，此时正是学习Swift的最佳时刻</li>
  <li>
    <p>截止至2019年6月，目前最新版本:Swift5.1</p>
  </li>
  <li>Swift完全开源: https://github.com/apple/swift，主要采用C++编写</li>
  <li>swiftc存放在Xcode内部
    <ul>
      <li>Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</li>
    </ul>
  </li>
  <li>一些操作
    <ul>
      <li>生成语法树: swiftc -dump-ast main.swift</li>
      <li>生成最简洁的SIL代码:swiftc -emit-sil main.swift</li>
      <li>生成LLVM IR代码: swiftc -emit-ir main.swift -o main.ll</li>
      <li>生成汇编代码: swiftc -emit-assembly main.swift -o main.s</li>
    </ul>
  </li>
  <li>对汇编代码进行分析，可以真正掌握编程语言的本质</li>
  <li>编译流程如下：</li>
</ul>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000001.jpg" alt="编译流程" /></p>

<hr />

<h3 id="程序的本质">程序的本质</h3>

<ul>
  <li>软件\程序的执行过程</li>
</ul>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000002.jpg" alt="" /></p>

<hr />

<h3 id="寄存器与内存">寄存器与内存</h3>

<ul>
  <li>
    <p>通常，CPU会先将内存中的数据存储到寄存器中，然后再对寄存器中的数据进行运算</p>
  </li>
  <li>
    <p>假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间</p>

    <ul>
      <li>CPU首先会将红色内存空间的值放到rax寄存器中:<code class="language-plaintext highlighter-rouge">movq 红色内存空间, %rax</code></li>
      <li>然后让rax寄存器与1相加:<code class="language-plaintext highlighter-rouge">addq $0x1, %rax</code></li>
      <li>最后将值赋值给内存空间:<code class="language-plaintext highlighter-rouge">movq %rax, 蓝色内存空间</code></li>
    </ul>

    <p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000003.jpg" alt="" /></p>
  </li>
</ul>

<hr />

<h3 id="编程语言的发展">编程语言的发展</h3>

<ul>
  <li>机器语言</li>
  <li>由0和1组成</li>
  <li>汇编语言(Assembly Language)
    <ul>
      <li>用符号代替了0和1，比机器语言便于阅读和记忆</li>
    </ul>
  </li>
  <li>高级语言
    <ul>
      <li>C\C++\Java\JavaScript\Python等，更接近人类自然语言</li>
    </ul>
  </li>
  <li>操作:将寄存器BX的内容送入寄存器AX
    <ul>
      <li>机器语言:1000100111011000</li>
      <li>汇编语言:movw %bx, %ax</li>
      <li>高级语言:ax = bx;</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="编程语言的发展-1">编程语言的发展</h3>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000004.jpg" alt="" /></p>

<ul>
  <li><strong>汇编语言</strong>与<strong>机器语言</strong>一一对应，每一条机器指令都有与之对应的汇编指令</li>
  <li><strong>汇编语言</strong>可以通过编译得到<strong>机器语言</strong>，<strong>机器语言</strong>可以通过反汇编得到<strong>汇编语言</strong></li>
  <li><strong>高级语言</strong>可以通过编译得到<strong>汇编语言</strong> \ <strong>机器语言</strong>，但<strong>汇编语言</strong> \ <strong>机器语言</strong>几乎不可能还原成<strong>高级语言</strong></li>
</ul>

<hr />

<h3 id="汇编语言的种类">汇编语言的种类</h3>

<ul>
  <li>
    <p>汇编语言的种类</p>
  </li>
  <li>
    <p>8086汇编(16bit)</p>
  </li>
  <li>
    <p>x86汇编(32bit)</p>
  </li>
  <li>
    <p>x64汇编(64bit)</p>
  </li>
  <li>
    <p>ARM汇编(嵌入式、移动设备)</p>
  </li>
  <li>
    <p>……</p>
  </li>
  <li>
    <p>x86、x64汇编根据编译器的不同，有2种书写格式</p>

    <ul>
      <li>Intel:Windows派系</li>
      <li>AT&amp;T :Unix派系</li>
    </ul>
  </li>
  <li>
    <p>作为iOS开发工程师，最主要的汇编语言是</p>

    <ul>
      <li>AT&amp;T汇编 -&gt; iOS模拟器</li>
      <li>ARM汇编 -&gt; iOS真机设备</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="常见汇编指令">常见汇编指令</h3>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000006.jpg" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>小括号代表里面装的是内存地址
-ox18(%rbp) 意思是 %rbp-0x18

movq -ox18(%rbp), %rax
mov是将内存空间存储的地址对应的值取出来，赋值给rax，q代表单位(8个字节)
leaq -0x18(%rbp), %rax
lea是直接算出地址将地址赋值给rax
jump跳转,跳转以后不回头
call跳转到指定地址执行代码，后面跟函数地址，一般跟ret配合使用，ret后回到call后的下一个地址
call *%rax 函数地址存储在rax中，记得加*

rip存储的是指令的地址
CPU要执行的下一条指令地址就存储在rip中 
</code></pre></div></div>

<hr />

<h3 id="寄存器">寄存器</h3>

<ul>
  <li>
    <p>有16个常用寄存器</p>

    <ul>
      <li>
        <p>rax、rbx、rcx 、rdx、rsi、rdi、rbp、rsp</p>
      </li>
      <li>
        <p>r8、r9、r10、r11、r12、r13、r14、r15</p>
      </li>
    </ul>
  </li>
  <li>
    <p>寄存器的具体用途</p>

    <ul>
      <li>rax、rdx常作为函数返回值使用</li>
      <li>rdi、rsi、rdx、rcx、r8、r9等寄存器常用于存放函数参数</li>
      <li>rsp、rbp用于栈操作</li>
      <li>rip作为指令指针
        <ul>
          <li>存储着CPU下一条要执行的指令的地址</li>
          <li>一旦CPU读取一条指令，rip会自动指向下一条指令(存储下一条指令的地址)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000005.jpg" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ah high 高位
al low 低位

r开头：64位，8个字节
e开头：32位，4个字节
ax,bx,cx : 16位，2字节
ah,al : 8位，1字节
bh bl
</code></pre></div></div>

<hr />

<h3 id="规律">规律</h3>

<ul>
  <li>内存地址格式为：0x4bdc(%rip)，一般是全局变量，全局区(数据段)</li>
  <li>内存地址格式为：-0x78(%rbp)，一般是局部变量，栈空间</li>
  <li>内存地址格式为：0x10(%rax)，一般是堆空间</li>
</ul>

<hr />

<h3 id="lldb常用指令">lldb常用指令</h3>

<ul>
  <li>
    <p>读取寄存器的值</p>

    <ul>
      <li>
        <p>register read/格式</p>
      </li>
      <li>
        <p>register read/x</p>
      </li>
    </ul>
  </li>
  <li>
    <p>修改寄存器的值</p>

    <ul>
      <li>
        <p>register write 寄存器名称 数值</p>
      </li>
      <li>
        <p>register write rax 0</p>
      </li>
    </ul>
  </li>
  <li>
    <p>读取内存中的值</p>

    <ul>
      <li>
        <p>x/数量-格式-字节大小 内存地址</p>
      </li>
      <li>
        <p>x/3xw 0x0000010</p>
      </li>
    </ul>
  </li>
  <li>
    <p>修改内存中的值</p>

    <ul>
      <li>
        <p>memory write 内存地址 数值</p>
      </li>
      <li>
        <p>memory write 0x0000010 10</p>
      </li>
    </ul>
  </li>
  <li>
    <p>格式</p>

    <ul>
      <li>x是16进制，f是浮点，d是十进制</li>
    </ul>
  </li>
  <li>
    <p>字节大小</p>

    <ul>
      <li>
        <p>b – byte 1字节</p>
      </li>
      <li>
        <p>h – half word 2字节</p>
      </li>
      <li>
        <p>w – word 4字节</p>
      </li>
      <li>
        <p>g – giant word 8字节</p>
      </li>
    </ul>
  </li>
  <li>
    <p>expression 表达式</p>
  </li>
  <li>
    <p>可以简写:expr 表达式</p>
  </li>
  <li>
    <p>expression $rax</p>
  </li>
  <li>
    <p>expression $rax = 1</p>
  </li>
  <li>
    <p>po 表达式</p>
  </li>
  <li>
    <p>print 表达式</p>

    <ul>
      <li>po/x $rax</li>
      <li>po (int)$rax</li>
    </ul>
  </li>
  <li>
    <p>thread step-over、next、n</p>

    <ul>
      <li>单步运⾏，把子函数当做整体⼀一步执行(源码级别)</li>
    </ul>
  </li>
  <li>
    <p>thread step-in、step、s</p>

    <ul>
      <li>单步运⾏，遇到子函数会进入子函数(源码级别)</li>
    </ul>
  </li>
  <li>
    <p>thread step-inst-over、nexti、ni</p>

    <ul>
      <li>单步运行，把子函数当做整体⼀一步执行(汇编级别)</li>
    </ul>
  </li>
  <li>
    <p>thread step-inst、stepi、si</p>
  </li>
  <li>
    <p>单步运⾏，遇到子函数会进入子函数(汇编级别)</p>
  </li>
  <li>
    <p>thread step-out、finish</p>

    <ul>
      <li>直接执⾏完当前函数的所有代码，返回到上一个函数(遇到断点会卡住)</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="规律-1">规律</h3>

<ul>
  <li>
    <p>内存地址格式为:<code class="language-plaintext highlighter-rouge">0x4bdc(%rip)</code>，一般是全局变量，全局区(数据段)</p>
  </li>
  <li>
    <p>内存地址格式为:<code class="language-plaintext highlighter-rouge">-0x78(%rbp)</code>，一般是局部变量，栈空间</p>
  </li>
  <li>
    <p>内存地址格式为:<code class="language-plaintext highlighter-rouge">0x10(%rax)</code>，一般是堆空间</p>
  </li>
</ul>

<hr />

<h2 id="基础语法">基础语法</h2>

<h3 id="hello-world">Hello World</h3>

<ul>
  <li>不用编写main函数，Swift将全局范围内的首句可执行代码作为程序入口</li>
  <li>一句代码尾部可以省略分号(;)，多句代码写到同一行时必须用分号(;)隔开</li>
  <li>用var定义变量，let定义常量，编译器能自动推断出变量\常量的类型</li>
  <li>Playground可以快速预览代码效果，是学习语法的好帮手</li>
  <li>Command + Shift + Enter:运行整个Playground</li>
  <li>Shift + Enter:运行截止到某一行代码</li>
</ul>

<hr />

<h3 id="playground---view">Playground - View</h3>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000007.jpg" alt="" /></p>

<hr />

<h3 id="playground---viewcontroller">Playground - ViewController</h3>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000008.jpg" alt="" /></p>

<hr />

<h3 id="playground--多page">Playground – 多Page</h3>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000009.jpg" alt="" /></p>

<hr />

<h3 id="注释">注释</h3>

<ul>
  <li>Playground的注释支持markup语法(与markdown相似)</li>
  <li>开启markup渲染效果:Editor -&gt; Show Rendered Markup</li>
  <li>注意:Markup只在Playground中有效</li>
</ul>

<pre><code class="language-objective-c">//单行注释

/*
 多行注释
 */

/*
 1
 /* 多行注释的嵌套 */
 2
*/

//: 开始markup

/* :
 开始markup
 */
</code></pre>

<hr />

<h3 id="常量">常量</h3>

<ul>
  <li>
    <p>只能赋值1次</p>
  </li>
  <li>
    <p>它的值不要求在编译时期确定，但使用之前必须赋值1次</p>
  </li>
</ul>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000010.jpg" alt="" /></p>

<ul>
  <li>
    <p>下面代码是错误的</p>

    <p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000012.jpg" alt="" /></p>
  </li>
  <li>
    <p>常量、变量在初始化之前，都不能使用</p>

    <p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000011.jpg" alt="" /></p>
  </li>
</ul>

<hr />

<h3 id="标识符">标识符</h3>

<ul>
  <li>
    <p>标识符(比如常量名、变量名、函数名)几乎可以使用任何字符</p>
  </li>
  <li>
    <p>标识符不能以数字开头，不能包含空白字符、制表符、箭头等特殊字符</p>
  </li>
</ul>

<p><img src="https://fuqionglin-blog.oss-cn-qingdao.aliyuncs.com/Swift5/000013.jpg" alt="" /></p>

<hr />

<h3 id="常见数据类型">常见数据类型</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">值类型(value type)</th>
      <th style="text-align: center">枚举(enum)</th>
      <th style="text-align: center">Optional</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">结构体(struct)</td>
      <td style="text-align: center">Bool、Int、Float、Double、Character</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">String、Array、Dictionary、Set</td>
    </tr>
    <tr>
      <td style="text-align: center">引用类型(reference type)</td>
      <td style="text-align: center">类(class)</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>整数类型:Int8、Int16、Int32、Int64、UInt8、UInt16、UInt32、UInt64</li>
  <li>
    <p>在32bit平台，Int等价于Int32;在64bit平台， Int等价于Int64</p>
  </li>
  <li>
    <p>整数的最值:UInt8.max、Int16.min</p>
  </li>
  <li>一般情况下，都是直接使用Int即可</li>
  <li>浮点类型:Float，32位，精度只有6位;Double，64位，精度至少15位</li>
</ul>

<hr />

<h3 id="字面量">字面量</h3>

<ul>
  <li>整数和浮点数可以添加额外的零或者添加下划线来增强可读性
    <ul>
      <li>100_1000、1_000_000.000_000_1、 000123.456</li>
    </ul>
  </li>
</ul>

<pre><code class="language-objective-c">//字符串
let string = "熊熊熊"

//字符（可存储ASCII字符、Unicode字符）
let character: Character = "🐶"

//布尔
let bool = true //取反是false

//整数
let intDecimal = 17 //十进制
let intBinary = 17 //二进制
let intOctal = 17 //八进制
let intHexadecimal = 17 //十六进制

//浮点数
let doubleDecimal = 125.0 //十进制，等价于1.25e2，0.0125等价于1.25e-2
let doubleHexadecimal1 = 0xFp2 //十六进制，意味着15x2^2，相当于十进制的60.0
let doubleHexadecimal2 = 0xFp-2 //十六进制，意味着15x2^-2，相当于十进制的3.75

//数组
let array = [1, 3, 5, 7, 9]

//字典
let dictionary = ["age" : 18, "height" : 168, "weight" : 120]
</code></pre>

<hr />

<h3 id="类型转换">类型转换</h3>

<pre><code class="language-objective-c">//整数转换
let int1: UInt16 = 2_000
let int2: UInt8 = 1
let int3 = int1 + UInt16(int2)

//整数、浮点数转换
let int = 3
let double = 0.14159
let pi = Double(int) + double
let intPi = Int(pi)
</code></pre>

<hr />

<h3 id="元祖">元祖</h3>

<pre><code class="language-objective-c">let http404Error = (404, "Not Found")
print("The status code is \(http404Error.0)")

let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")

let (justTheStatusCode, _) = http404Error

let http200Status = (statusCode: 200, description: "OK")
print("The status code is \(http200Status.statusCode)")
</code></pre>

:ET